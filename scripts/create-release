#!/usr/bin/env bash
#
# Automated release script for cassh
# Usage: ./scripts/create-release [VERSION]
#
# This script:
# 1. Validates version format
# 2. Generates changelog from commits since last tag
# 3. Updates CHANGELOG.md
# 4. Commits the changelog
# 5. Creates a git tag
# 6. Pushes tag to trigger release workflow
#
# Example: ./scripts/create-release 1.2.0

set -euo pipefail

VERSION="${1:-}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Help message
if [ -z "$VERSION" ] || [ "$VERSION" = "-h" ] || [ "$VERSION" = "--help" ]; then
    echo "Usage: $0 VERSION"
    echo ""
    echo "Example: $0 1.2.0"
    echo ""
    echo "This script will:"
    echo "  1. Generate changelog from commits"
    echo "  2. Update CHANGELOG.md"
    echo "  3. Commit the changelog"
    echo "  4. Create and push git tag v\$VERSION"
    echo "  5. Trigger GitHub Actions release workflow"
    exit 0
fi

# Validate version format (semantic versioning)
if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo -e "${RED}Error: Version must be in format X.Y.Z (e.g., 1.2.0)${NC}" >&2
    exit 1
fi

TAG="v${VERSION}"

# Check if tag already exists
if git rev-parse "$TAG" >/dev/null 2>&1; then
    echo -e "${RED}Error: Tag $TAG already exists${NC}" >&2
    exit 1
fi

# Check if working directory is clean
if ! git diff-index --quiet HEAD --; then
    echo -e "${YELLOW}Warning: You have uncommitted changes.${NC}"
    echo "Please commit or stash your changes before creating a release."
    exit 1
fi

# Get the previous tag
PREV_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
if [ -z "$PREV_TAG" ]; then
    echo -e "${YELLOW}Warning: No previous tag found. Generating changelog from first commit.${NC}"
    PREV_TAG=$(git rev-list --max-parents=0 HEAD)
fi

echo -e "${GREEN}Creating release ${TAG}${NC}"
echo "Previous version: ${PREV_TAG}"
echo ""

# Generate changelog
echo "Generating changelog from ${PREV_TAG} to HEAD..."
CHANGELOG_CONTENT=$(./scripts/generate-changelog "$PREV_TAG" "HEAD")

# Show changelog preview
echo ""
echo -e "${GREEN}=== Generated Changelog ===${NC}"
echo "$CHANGELOG_CONTENT"
echo -e "${GREEN}===========================${NC}"
echo ""

# Ask for confirmation
read -p "Does this changelog look correct? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Release cancelled.${NC}"
    exit 0
fi

# Backup CHANGELOG.md
cp CHANGELOG.md CHANGELOG.md.bak

# Update CHANGELOG.md
# Insert the new version after the [Unreleased] section
if grep -q "## \[Unreleased\]" CHANGELOG.md; then
    # Create temp file with new changelog
    {
        # Everything before and including [Unreleased]
        sed -n '1,/## \[Unreleased\]/p' CHANGELOG.md
        echo ""
        # New version changelog (skip the version header, we'll add it)
        echo "$CHANGELOG_CONTENT"
        echo ""
        # Everything after [Unreleased] section (skip empty line after it)
        sed -n '/## \[Unreleased\]/,$ {
            /## \[Unreleased\]/d
            /^$/d
            p
        }' CHANGELOG.md | sed '1,/^$/d'
    } > CHANGELOG.md.tmp
    mv CHANGELOG.md.tmp CHANGELOG.md
else
    # No [Unreleased] section, just prepend
    # Determine where changelog entries begin by finding the first "## [" header.
    # This avoids assuming a fixed header length, which is fragile if the header changes.
    first_entry_line=$(grep -n '^## \[' CHANGELOG.md | head -n 1 | cut -d: -f1 || true)
    if [ -n "${first_entry_line:-}" ]; then
        header_end_line=$(( first_entry_line - 1 ))
        tail_start_line=$first_entry_line
    else
        # Fallback to previous behavior if no "## [" section headers are found.
        header_end_line=8
        tail_start_line=9
    fi

    {
        head -n "$header_end_line" CHANGELOG.md  # Keep header
        echo ""
        echo "$CHANGELOG_CONTENT"
        echo ""
        tail -n +"$tail_start_line" CHANGELOG.md  # Rest of file
    } > CHANGELOG.md.tmp
    mv CHANGELOG.md.tmp CHANGELOG.md
fi

# Show diff
echo ""
echo -e "${GREEN}=== CHANGELOG.md diff ===${NC}"
git diff CHANGELOG.md
echo -e "${GREEN}========================${NC}"
echo ""

# Ask for final confirmation
read -p "Commit and create release tag? (y/N) " -n 1 -r
echo
if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo -e "${YELLOW}Release cancelled. Restoring CHANGELOG.md${NC}"
    mv CHANGELOG.md.bak CHANGELOG.md
    exit 0
fi

# Clean up backup
rm -f CHANGELOG.md.bak

# Commit changelog
git add CHANGELOG.md
git commit -m "chore: Release v${VERSION}

Update CHANGELOG.md with release notes for v${VERSION}

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

# Create annotated tag
git tag -a "$TAG" -m "Release ${VERSION}

$(echo "$CHANGELOG_CONTENT" | sed '1,2d')

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"

echo ""
echo -e "${GREEN}âœ“ Created tag ${TAG}${NC}"
echo ""

# Push changes and tag
echo "Pushing to origin..."
CURRENT_BRANCH="$(git branch --show-current)"
if [ -z "$CURRENT_BRANCH" ]; then
    echo -e "${RED}âœ— Unable to determine current git branch (detached HEAD?). Aborting push.${NC}" >&2
    exit 1
fi
git push origin "$CURRENT_BRANCH"
git push origin "$TAG"

echo ""
echo -e "${GREEN}âœ“ Release ${TAG} created successfully!${NC}"
echo ""
echo "GitHub Actions will now:"
echo "  1. Build macOS PKG (signed and notarized)"
echo "  2. Build Linux server binary"
echo "  3. Create GitHub Release with changelog"
echo "  4. Update Homebrew tap"
echo ""
echo "Monitor the release at:"
REPO_URL=$(git remote get-url origin | sed 's/\.git$//' | sed 's/git@github.com:/https:\/\/github.com\//')
echo "  ${REPO_URL}/releases/tag/${TAG}"
echo "  ${REPO_URL}/actions"
